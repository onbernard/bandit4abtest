for(i in levels(as.factor(dt$groups ))){
message(paste("subset",i,sep=" "))
#Subset visitors from this segment
visitor_reward_for_ctree <- subset.data.frame(dt,dt$groups== i)
visitor_reward_for_ctree <-  visitor_reward_for_ctree [,(ncol(visitor_reward_for_ctree) -K+1):ncol(visitor_reward_for_ctree )]
#UCB results
ucb_temp_res <- UCB_rejection_sampling(visitorReward=visitor_reward_for_ctree , K=K ,alpha =ctree_parameters_control$alpha)
#update choice vector
dt[dt$groups==i,]$choice  <-ucb_temp_res$choice
#Save results
Ctree_object <- c(Ctree_object,list(i,ucb_temp_res))
rm(ucb_temp_res)
}
size.tot = 9000
set.seed(4649)                          # this makes the example exactly reproducible
x1 = runif(size.tot, min=0, max=10)          # you have 4, largely uncorrelated predictors
x2 = runif(size.tot, min=0, max=10)
x3 = runif(size.tot, min=0, max=10)
x4 = runif(size.tot, min=0, max=10)
dt = cbind(x1,x2,x3,x4)
arm_1 <-  as.vector(c(-1,9,-8,4))
K1 = crossprod(t(dt),arm_1)
arm_2 <-  as.vector(c(-1,2,1,0))
K2 = crossprod(t(dt),arm_2)
arm_3 <-  as.vector(c(-1,-5,1,10))
K3 = crossprod(t(dt),arm_3)
visitor_reward <-  data.frame(K1,K2,K3)
dt <- as.data.frame(dt)
size.tot = 9000
# Time series
alpha_list <- c(1,2,3)
beta_list <- c(0.5,0.1,-0.2)
theta_list <- c(0.8,0.2,0.5)
y <- as.data.frame(c(1))
colnames(y) = "ID"
temp=1
for (j in 1:3000){
for (i in 1:length(alpha_list)){
n = sample(1:100,1)
t <- 1:n
ts <- alpha_list[i] + beta_list[i] * t + arima.sim(list(ma = theta_list[i]), n = length(t))
y[temp, "time_series"][[1]] <- list(ts)
y[temp, "cluster"][[1]] <- i
y$ID[temp] = temp
temp = temp +1
}
}
y <- y[sample(nrow(y)),]
dt <-  as.data.frame(cbind(x1,x2,x3,x4,y$time_series))
colnames(dt) <- c("x1","x2","x3","x4","time_series")
for(i in 1:nrow(dt)) {
if(y$cluster[i] == 1) visitor_reward$K1[i] = 10
if(y$cluster[i] == 2) visitor_reward$K2[i] = 20
if(y$cluster[i] == 3) visitor_reward$K3[i] = 30
}
dt$cluster <- NULL
dt$x1 <- as.numeric(dt$x1)
dt$x2 <- as.numeric(dt$x2)
dt$x3 <- as.numeric(dt$x3)
dt$x4 <- as.numeric(dt$x4)
K=ncol(visitor_reward)
ctree_parameters_control=ctreeucb_parameters_control_default(dt,visitor_reward)
ctree_parameters_control$ctree_control_val$minprob = 0.05
ctree_parameters_control$explanatory_variable
listSerie = c("time_series")
listKCentroids=c(3)
dbactreeucb_rejection_sampling(dt,visitor_reward,K=ncol(visitor_reward), listKCentroids , ctree_parameters_control)){
dbactreeucb_rejection_sampling(dt,visitor_reward,K=ncol(visitor_reward), listKCentroids , ctree_parameters_control))
dbactreeucb_rejection_sampling(dt,visitor_reward,K=ncol(visitor_reward), listKCentroids , ctree_parameters_control)
#'#remove data
#'temp_list <- sample(1:nrow(visitor_reward), as.integer(size.tot/2) , replace = FALSE, prob = NULL)
#'visitor_reward$K1[temp_list] <- NA
#'visitor_reward$K2[-temp_list] <- NA
#'#run ucb on missing data
#'ctreeucb_rejection_sampling(dt,visitor_reward)
#'@import tictoc
#'
#'@export
#dbactreeucb_rejection_sampling agorithm
dbactreeucb_rejection_sampling <- function(dt,visitor_reward,K=ncol(visitor_reward), listSerie, listKCentroids , ctree_parameters_control=ctreeucb_parameters_control_default(dt,visitor_reward)){
# set.seed(4321)
### control ###
#data controle
DataControlK(visitor_reward, K = K)
library(dplyr)
DataControlContextReward(dt%>% select(-listSerie), visitor_reward)
#Change the type of data TO CHECK
#temp <-changeDataTypeForCtreeUCB(dt=dt,visitor_reward=visitor_reward,is_reward_are_boolean=ctree_parameters_control$is_reward_are_boolean)
#dt <- temp$dt
#if reward is boolean, data will be modify temporary
#temp.visitor_reward <- temp$visitor_reward
### learning  ###
#Learn Clustering
obj <- createClusters(listSerie = listSerie , dt = dt[1:ctree_parameters_control$learn_size , ] , method = "DBA" , listKCentroids=listKCentroids , plotCentroids = TRUE , plotClusters = TRUE , maxIter = 10L )
#centroid <- obj$clust_obj[[1]]@centroids
#dt$cluster <- NA
#dt[1:ctree_parameters_control$learn_size , ]$cluster <- obj$dt$cluster
#dt$cluster <- as.factor(dt$cluster)
#Add clusters
for(i in 1:length(listSerie)) dt[[paste("cluster",listSerie[i],sep = "")]] <- 0
for(i in 1:length(listSerie)){
dt[[paste("cluster",listSerie[i],sep = "")]][1:ctree_parameters_control$learn_size] <- obj$clust_obj[[i]]@cluster
#Add cluster to explanatory variables
ctree_parameters_control$explanatory_variable <- c( ctree_parameters_control$explanatory_variable,paste("cluster",listSerie[i],sep = ""))
}
for(i in 1:length(listSerie)) dt[[paste("cluster",listSerie[i],sep = "")]] <- as.factor(dt[[paste("cluster",listSerie[i],sep = "")]])
temp_list =  ctree_parameters_control$explanatory_variable
#Remove series for ctreeucb learning step (we keep the clusters)
temp_list =  temp_list[ temp_list !=  listSerie]
#Generate formula and tree
ctree_tree <- ctree_formula_generate(dt = dt,
visitor_reward = visitor_reward,
# visitor_reward = temp.visitor_reward,
ctree_control_val = ctree_parameters_control$ctree_control_val,
arm_for_learn = ctree_parameters_control$arm_for_learn,
explanatory_variable= temp_list,
learn_size = ctree_parameters_control$learn_size,
print=TRUE)
#return to regular data
visitor_reward <- visitor_reward
#remove the learn set
dt.old <- dt
#update handle one covariate
if(length(ctree_parameters_control$explanatory_variable)==1){
dt <- as.data.frame(dt[c((ctree_parameters_control$learn_size+1):nrow(dt)),])
colnames(dt) <- c("x")
}else{
dt <- dt[c((ctree_parameters_control$learn_size+1):nrow(dt)),]
}
visitor_reward <- visitor_reward[c((ctree_parameters_control$learn_size+1):nrow(visitor_reward)),]
### Training  ###
#define cluster for each item
k=0
temp_i=0
for(i in listSerie){
print(i)
temp_i = temp_i + 1
k <- k + 1
for(j in (as.integer( ctree_parameters_control$learn_size  )+1): nrow(dt)){
#print(j)
temp_clust = 1
temp_clust_dist  = dtw2(unlist(dt[[i]][j]), unlist(obj$clust_obj[[1]]@centroids[1]))$distance
for(l in 2:listKCentroids[k]){
#init
if(temp_clust_dist > dtw2(unlist(dt[[i]][j]), unlist(obj$clust_obj[[1]]@centroids[l]))$distance){
temp_clust = l
temp_clust_dist  =  dtw2(unlist(dt[[i]][j]), unlist(obj$clust_obj[[1]]@centroids[1]))$distance
}
}
dt[[paste("cluster",listSerie[k],sep = "")]][j] <- as.factor( temp_clust )
}
}
######
dt$groups <- predict(ctree_tree, newdata=dt, type="node")
dt$choice <- 0
dt$regret <- NA
dt <- cbind(dt,visitor_reward)
groups <- dt$groups
#object for stores choices
choices <- c( rep(0,nrow(visitor_reward)))
Ctree_object <- list()
#start ucb for set upper than learn set
#get the number of arm
K= ncol(visitor_reward)
tic()
#for each groups play a private strategy of ucb
for(i in levels(as.factor(dt$groups ))){
message(paste("subset",i,sep=" "))
#Subset visitors from this segment
visitor_reward_for_ctree <- subset.data.frame(dt,dt$groups== i)
visitor_reward_for_ctree <-  visitor_reward_for_ctree [,(ncol(visitor_reward_for_ctree) -K+1):ncol(visitor_reward_for_ctree )]
#UCB results
ucb_temp_res <- UCB_rejection_sampling(visitorReward=visitor_reward_for_ctree , K=K ,alpha =ctree_parameters_control$alpha)
#update choice vector
dt[dt$groups==i,]$choice  <-ucb_temp_res$choice
#Save results
Ctree_object <- c(Ctree_object,list(i,ucb_temp_res))
rm(ucb_temp_res)
}
time <- toc()
#return  data , models, groups and results
return(list('data_reward'=visitor_reward,'data_context'=dt,'groups'=groups,'ctree_ucb'=Ctree_object,'first_train_element'=(ctree_parameters_control$learn_size+1) ,'time'=(time$toc - time$tic),'choice'=dt$choice,'tree'= ctree_tree))
}
dbactreeucb_rejection_sampling(dt,visitor_reward,K, listSerie, listKCentroids , ctree_parameters_control)
# set.seed(4321)
### control ###
#data controle
DataControlK(visitor_reward, K = K)
library(dplyr)
DataControlContextReward(dt%>% select(-listSerie), visitor_reward)
#Change the type of data TO CHECK
#temp <-changeDataTypeForCtreeUCB(dt=dt,visitor_reward=visitor_reward,is_reward_are_boolean=ctree_parameters_control$is_reward_are_boolean)
#dt <- temp$dt
#if reward is boolean, data will be modify temporary
#temp.visitor_reward <- temp$visitor_reward
### learning  ###
#Learn Clustering
obj <- createClusters(listSerie = listSerie , dt = dt[1:ctree_parameters_control$learn_size , ] , method = "DBA" , listKCentroids=listKCentroids , plotCentroids = TRUE , plotClusters = TRUE , maxIter = 10L )
#centroid <- obj$clust_obj[[1]]@centroids
#dt$cluster <- NA
#dt[1:ctree_parameters_control$learn_size , ]$cluster <- obj$dt$cluster
#dt$cluster <- as.factor(dt$cluster)
#Add clusters
for(i in 1:length(listSerie)) dt[[paste("cluster",listSerie[i],sep = "")]] <- 0
for(i in 1:length(listSerie)){
dt[[paste("cluster",listSerie[i],sep = "")]][1:ctree_parameters_control$learn_size] <- obj$clust_obj[[i]]@cluster
#Add cluster to explanatory variables
ctree_parameters_control$explanatory_variable <- c( ctree_parameters_control$explanatory_variable,paste("cluster",listSerie[i],sep = ""))
}
for(i in 1:length(listSerie)) dt[[paste("cluster",listSerie[i],sep = "")]] <- as.factor(dt[[paste("cluster",listSerie[i],sep = "")]])
temp_list =  ctree_parameters_control$explanatory_variable
#Remove series for ctreeucb learning step (we keep the clusters)
temp_list =  temp_list[ temp_list !=  listSerie]
#Generate formula and tree
ctree_tree <- ctree_formula_generate(dt = dt,
visitor_reward = visitor_reward,
# visitor_reward = temp.visitor_reward,
ctree_control_val = ctree_parameters_control$ctree_control_val,
arm_for_learn = ctree_parameters_control$arm_for_learn,
explanatory_variable= temp_list,
learn_size = ctree_parameters_control$learn_size,
print=TRUE)
#return to regular data
visitor_reward <- visitor_reward
#remove the learn set
dt.old <- dt
#update handle one covariate
if(length(ctree_parameters_control$explanatory_variable)==1){
dt <- as.data.frame(dt[c((ctree_parameters_control$learn_size+1):nrow(dt)),])
colnames(dt) <- c("x")
}else{
dt <- dt[c((ctree_parameters_control$learn_size+1):nrow(dt)),]
}
visitor_reward <- visitor_reward[c((ctree_parameters_control$learn_size+1):nrow(visitor_reward)),]
### Training  ###
#define cluster for each item
k=0
temp_i=0
for(i in listSerie){
print(i)
temp_i = temp_i + 1
k <- k + 1
for(j in (as.integer( ctree_parameters_control$learn_size  )+1): nrow(dt)){
#print(j)
temp_clust = 1
temp_clust_dist  = dtw2(unlist(dt[[i]][j]), unlist(obj$clust_obj[[1]]@centroids[1]))$distance
for(l in 2:listKCentroids[k]){
#init
if(temp_clust_dist > dtw2(unlist(dt[[i]][j]), unlist(obj$clust_obj[[1]]@centroids[l]))$distance){
temp_clust = l
temp_clust_dist  =  dtw2(unlist(dt[[i]][j]), unlist(obj$clust_obj[[1]]@centroids[1]))$distance
}
}
dt[[paste("cluster",listSerie[k],sep = "")]][j] <- as.factor( temp_clust )
}
}
######
View(visitor_reward)
View(dt.old)
dt$groups <- predict(ctree_tree, newdata=dt, type="node")
View(dt)
dt[[paste("cluster",listSerie[k],sep = "")]][901]
dt[[paste("cluster",listSerie[k],sep = "")]][1]
j=1
#define cluster for each item
k=0
temp_i=0
for(i in listSerie){
print(i)
temp_i = temp_i + 1
k <- k + 1
for(j in 1: nrow(dt)){
#print(j)
temp_clust = 1
temp_clust_dist  = dtw2(unlist(dt[[i]][j]), unlist(obj$clust_obj[[1]]@centroids[1]))$distance
for(l in 2:listKCentroids[k]){
#init
if(temp_clust_dist > dtw2(unlist(dt[[i]][j]), unlist(obj$clust_obj[[1]]@centroids[l]))$distance){
temp_clust = l
temp_clust_dist  =  dtw2(unlist(dt[[i]][j]), unlist(obj$clust_obj[[1]]@centroids[1]))$distance
}
}
dt[[paste("cluster",listSerie[k],sep = "")]][j] <- as.factor( temp_clust )
}
}
dt$groups <- predict(ctree_tree, newdata=dt, type="node")
dt$choice <- 0
dt$regret <- NA
dt <- cbind(dt,visitor_reward)
groups <- dt$groups
#object for stores choices
choices <- c( rep(0,nrow(visitor_reward)))
Ctree_object <- list()
#start ucb for set upper than learn set
#get the number of arm
K= ncol(visitor_reward)
tic()
#for each groups play a private strategy of ucb
for(i in levels(as.factor(dt$groups ))){
message(paste("subset",i,sep=" "))
#Subset visitors from this segment
visitor_reward_for_ctree <- subset.data.frame(dt,dt$groups== i)
visitor_reward_for_ctree <-  visitor_reward_for_ctree [,(ncol(visitor_reward_for_ctree) -K+1):ncol(visitor_reward_for_ctree )]
#UCB results
ucb_temp_res <- UCB_rejection_sampling(visitorReward=visitor_reward_for_ctree , K=K ,alpha =ctree_parameters_control$alpha)
#update choice vector
dt[dt$groups==i,]$choice  <-ucb_temp_res$choice
#Save results
Ctree_object <- c(Ctree_object,list(i,ucb_temp_res))
rm(ucb_temp_res)
}
time <- toc()
library(devtools)
check()
load("~/Documents/cours/S6/bandit/bandit4abtest/R/sysdata.rda")
document()
check()
document()
check()
library(devtools)
check()
document()
install.packages(dtwcluster)
install.packages(dtwclust)
install.packages("dtwclust")
?makeCluster
?clusterEvalQ
?registerDoParellel
?registerDoParallel
?tsclust
?stopCluster
?registerDoSEQ
document()
check()
document()
?clusterEvalQ
?dtwclust
?library
?invisible
?clusterEvalQ
document()
?createClusters
load_all()
document()
check()
rename_files("ctreeucb_rejection_sampling algorithm.R", "ctreeucb_rejection_sampling_algorithm.R")
check()
document()
check()
?tic
class(1:4)
class(c(1:4))
rename_files("UCB.R", "policy_ucb.R")
library(devtools)
library(fs)
?fs
library(tidyverse)
rename_files("UCB.R", "policy_ucb.R")
usethis::use_testthat()
?testthat
rename_files("bandit_reward_control.R", "input_control.R")
rename_files("input_control.R", "bandit_reward_control.R")
use_test("bandit_reward_control")
is.data.frame(c(1))
is.data.frame(as.data.frame(c(1)))
?stopifnot
is.integer(c(1))
is.integer(1)
is.integer(1L)
1:1.3
is.numeric(1)
is.numeric(TRUE)
is.numeric(c(1,2))
1:c(1,2)
is.na(NA)
is.na(c(NA))
is.na(c(NA,1))
t <- as.data.frame(cbind(c(NA,1),c(2,2)))
t
is.na(t)
exists(is.na(t))
?exists
?foreach
?forall
any(is.na(t))
?stop
as.data.frame(c())
a <- as.data.frame(c())
a
tf <- function() (stop("lol"); return(TRUE))
tf <- function() (stop("lol"))
tf()
tf <- function() (stop("lol") return(TRUE))
tf <- function() {stop("lol"); return(TRUE)}
tf()
tf <- function(x) {if(x==1){stop("lol")}else{ return(TRUE)}}
tf(1)
tf(2)
as.data.frame(c(1,2,3))
as.data.frame(c(1,2,TRUE))
data(c(1,2))
data_frame(c(1,2))
tibble(c(1,2))
is.data.frame(tibble(c(1,2)))
w <- tibble(c(1,2))
nrow(w)
?tibble
as.data.frame(matrix(0,1))
as.data.frame(matrix(0,5))
as.data.frame(matrix(0,3,5))
as.data.frame(matrix(0,5,3))
as.data.frame(matrix(0,2,3))
as.data.frame(cbind(c(NA,1,2),
c(2,3,5)))
test()
test()
document()
document()
?UCB
class(matrix(0,2,2))
class(matrix(TRUE,2,2))
matrix(TRUE,2,2)
?colMeans
colMeans(c(1,1))
colMeans(diag(2,2))
rename_files("proba_max_for_UCB.R", "proba_max_for_ucb.R")
paste('bandit', 1:5)
use_test("generate_matrix_S")
identical(matrix(0,3,3), matrix(0,3,3))
identical(matrix(0,3,3), matrix(0,3,4))
identical(matrix(0,3,3), matrix(1,3,3))
test()
test()
document()
is.numeric(1L)
document()
rename_files("thompson_sampling.R", "policy_thompson_sampling.R")
?mapply
t
mapply(f(v)(v!=1 && v!=0), t)
mapply(function(v)(v!=1 && v!=0), t)
mapply(function(v)(v!=1 && v!=0), diag(3))
mapply(function(v)(v!=1 && v!=0), matrix(4,3,4))
v <- as.date.frame(cbind(c(TRUE,FALSE),c(FALSE,FALSE)))
v <- as.datA.frame(cbind(c(TRUE,FALSE),c(FALSE,FALSE)))
v <- as.data.frame(cbind(c(TRUE,FALSE),c(FALSE,FALSE)))
v
as.matrix(v)
mapply(function(v)(v!=1 && v!=0), v)
mapply(function(v)(v!=1 && v!=0), as.matrix(v))
FALSE==1
FALSE==0
as.integer(TRUE)
v
c(TRUE,1)
t
is.na(t)
v
as.integer(v)
mapply(as.integer,as.matrix(v))
as.matrix(v)
mapply(function(v)(v==1 || v==0),as.matrix(v))
as.integer(TRUE)
TRUE!= 0
TRUE!= 1
TRUE!=1 && TRUE!=0
2!=1 && 2!=0
matrix(c(1,2,3,4), nrow=2,ncol=2)
sapply(as.logical, diag(3))
sapply(diag(3), as.logical)
TRUE + 1
TRUE * 1
1 / FALSE
t
mapply(function(v)(v!=1 && v!=0), t)
?is.na
v
v * 1
use_test("control_binary")
c(TRUE,1)
is.numeric(TRUE)
cbind(c("lol","lol"),c(TRUE,FALSE))
a <- cbind(c("lol","lol"),c(TRUE,FALSE))
a*1
"lol"==1
mapply(function(v)(v!=1 && v!=0),a)
as.numeric(a)
is.numeric(a)
is.numeric(diag(3))
is.numeric(matrix(TRUE,2,3))
?stopifnot
t
is.numeric(TRUE)
a
is.numeric(a)
is.numeric(diag(3))
test()
cbind(c(TRUE,FALSE),c(1,2))
test()
matrix(TRUE,2,3)
matrix(TRUE,2,3) * 1
?rbeta
?max
?rbeta
rename_files("epsilon_greedy.R", "policy_epsilon_greedy.R")
rename_files("EXP3.R", "policy_exp3.R")
class(1L)
is.integer(1L)
is.numeric(1L)
document()
document()
document()
